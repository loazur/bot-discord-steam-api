'use strict';

var jpegJs = require('jpeg-js');
var ndarray = require('ndarray');
var pngjs = require('pngjs');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var ndarray__default = /*#__PURE__*/_interopDefault(ndarray);

// src/get-pixels.ts
var parseImageBuffer = (image) => {
  switch (image.fileType) {
    case "image/png": {
      const png = pngjs.PNG.sync.read(Buffer.from(image.buffer));
      return ndarray__default.default(
        new Uint8Array(png.data),
        [png.width | 0, png.height | 0, 4],
        [4, 4 * png.width | 0, 1],
        0
      );
    }
    case "image/jpg":
    case "image/jpeg": {
      const jpeg = jpegJs.decode(image.buffer);
      return ndarray__default.default(new Uint8Array(jpeg.data), [jpeg.height, jpeg.width, 4]).transpose(1, 0);
    }
    default:
      throw new Error(
        `Unsupported mime-type ${image.fileType}, Only PNG and JPG are currently supported`
      );
  }
};
var getPixelsFromURL = async (src) => {
  const image = await fetch(src).then(async (resp) => ({
    buffer: await resp.arrayBuffer(),
    fileType: resp.headers.get("content-type") || ""
  }));
  return parseImageBuffer(image);
};

// src/quantize.ts
var sigBits = 5;
var rightShift = 8 - sigBits;
var maxIterations = 1e3;
var fractionByPopulations = 0.75;
var PriorityQueue = class extends Array {
  constructor(compareFn) {
    super();
    this.compareFn = compareFn;
  }
  sorted = false;
  sort(compareFn) {
    super.sort(compareFn || this.compareFn);
    this.sorted = true;
    return this;
  }
  push(...items) {
    super.push(...items);
    this.sorted = false;
    return this.length;
  }
  find(predicate) {
    if (!this.sorted)
      this.sort();
    return super.find(predicate);
  }
  pop() {
    if (!this.sorted)
      this.sort();
    return super.pop();
  }
  forEach(callbackfn, thisArg) {
    if (!this.sorted)
      this.sort();
    super.forEach(callbackfn, thisArg);
  }
};
var getColorIndex = (r, g, b) => (r << 2 * sigBits) + (g << sigBits) + b;
var VBox = class _VBox {
  constructor(r, g, b, histogram) {
    this.r = r;
    this.g = g;
    this.b = b;
    this.histogram = histogram;
  }
  cachedVolume = null;
  cachedCount = null;
  cachedAverageColor = null;
  volume(force) {
    if (!this.cachedVolume || force) {
      this.cachedVolume = (this.r[1] - this.r[0] + 1) * (this.g[1] - this.g[0] + 1) * (this.b[1] - this.b[0] + 1);
    }
    return this.cachedVolume;
  }
  count(force) {
    if (!this.cachedCount || force) {
      this.cachedCount = 0;
      for (let i = this.r[0]; i <= this.r[1]; i++) {
        for (let j = this.g[0]; j <= this.g[1]; j++) {
          for (let k = this.b[0]; k <= this.b[1]; k++) {
            const index = getColorIndex(i, j, k);
            this.cachedCount += this.histogram[index] || 0;
          }
        }
      }
    }
    return this.cachedCount;
  }
  copy() {
    return new _VBox(
      [this.r[0], this.r[1]],
      [this.g[0], this.g[1]],
      [this.b[0], this.b[1]],
      this.histogram.slice()
    );
  }
  average(force) {
    if (!this.cachedAverageColor || force) {
      let totalHistogramValue = 0;
      const multiplicate = 1 << 8 - sigBits;
      let rSum = 0;
      let gSum = 0;
      let bSum = 0;
      for (let i = this.r[0]; i <= this.r[1]; i++) {
        for (let j = this.g[0]; j <= this.g[1]; j++) {
          for (let k = this.b[0]; k <= this.b[1]; k++) {
            const index = getColorIndex(i, j, k);
            const histogramValue = this.histogram[index] || 0;
            totalHistogramValue += histogramValue;
            rSum += histogramValue * (i + 0.5) * multiplicate;
            gSum += histogramValue * (j + 0.5) * multiplicate;
            bSum += histogramValue * (k + 0.5) * multiplicate;
          }
        }
      }
      if (totalHistogramValue) {
        this.cachedAverageColor = [
          Math.trunc(rSum / totalHistogramValue),
          Math.trunc(gSum / totalHistogramValue),
          Math.trunc(bSum / totalHistogramValue)
        ];
      } else {
        this.cachedAverageColor = [
          Math.trunc(multiplicate * (this.r[0] + this.r[1] + 1) / 2),
          Math.trunc(multiplicate * (this.g[0] + this.g[1] + 1) / 2),
          Math.trunc(multiplicate * (this.b[0] + this.b[1] + 1) / 2)
        ];
      }
    }
    return this.cachedAverageColor;
  }
  contains(pixel) {
    const [r, g, b] = pixel.map((val) => val >> rightShift);
    return r >= this.r[0] && r <= this.r[1] && g >= this.g[0] && g <= this.g[1] && b >= this.b[0] && b <= this.b[1];
  }
};
var CMap = class {
  vBoxes;
  constructor() {
    this.vBoxes = new PriorityQueue(
      (a, b) => a.vbox.count() * a.vbox.volume() - b.vbox.count() * b.vbox.volume()
    );
  }
  push(vbox) {
    this.vBoxes.push({
      vbox,
      color: vbox.average()
    });
  }
  palette() {
    return Array.from(this.vBoxes.map(({ color }) => color));
  }
  get size() {
    return this.vBoxes.length;
  }
  map(color) {
    return this.vBoxes.find(({ vbox }) => vbox.contains(color))?.color || this.nearest(color);
  }
  nearest(color) {
    let d1 = Number.MAX_SAFE_INTEGER;
    let d2;
    let pColor = [0, 0, 0];
    for (const { color: vColor } of this.vBoxes) {
      d2 = Math.sqrt(
        (color[0] - vColor[0]) ** 2 + (color[1] - vColor[1]) ** 2 + (color[2] - vColor[2]) ** 2
      );
      if (d2 < d1) {
        d1 = d2;
        pColor = vColor;
      }
    }
    return pColor;
  }
  forceBW() {
    this.vBoxes.sort(
      (a, b) => a.color.reduce((x, y) => x + y, 0) - b.color.reduce((x, y) => x + y, 0)
    );
    const lowest = this.vBoxes[0].color;
    if (lowest[0] < 5 && lowest[1] < 5 && lowest[2] < 5)
      this.vBoxes[0].color = [0, 0, 0];
    const idx = this.vBoxes.length - 1;
    const highest = this.vBoxes[idx].color;
    if (highest[0] > 251 && highest[1] > 251 && highest[2] > 251) {
      this.vBoxes[idx].color = [255, 255, 255];
    }
  }
};
var getHistogram = (pixels) => {
  const histogramSize = 1 << 3 * sigBits;
  const histogram = new Array(histogramSize);
  for (const pixel of pixels) {
    const index = getColorIndex(...pixel.map((val) => val >> rightShift));
    histogram[index] = (histogram[index] || 0) + 1;
  }
  return histogram;
};
var vBoxFromPixels = (pixels, histogram) => {
  const rRange = [Number.MAX_SAFE_INTEGER, 0];
  const gRange = [Number.MAX_SAFE_INTEGER, 0];
  const bRange = [Number.MAX_SAFE_INTEGER, 0];
  for (const pixel of pixels) {
    const [r, g, b] = pixel.map((val) => val >> rightShift);
    if (r < rRange[0]) {
      rRange[0] = r;
    } else if (r > rRange[1]) {
      rRange[1] = r;
    }
    if (g < gRange[0]) {
      gRange[0] = g;
    } else if (g > gRange[1]) {
      gRange[1] = g;
    }
    if (b < bRange[0]) {
      bRange[0] = b;
    } else if (b > bRange[1]) {
      bRange[1] = b;
    }
  }
  return new VBox(rRange, gRange, bRange, histogram);
};
var medianCutApply = (histogram, vbox) => {
  if (vbox.count() === 0) {
    throw new Error("vbox should have pixels");
  }
  if (vbox.count() === 1) {
    return [vbox.copy(), null];
  }
  const rWidth = vbox.r[1] - vbox.r[0] + 1;
  const gWidth = vbox.g[1] - vbox.g[0] + 1;
  const bWidth = vbox.b[1] - vbox.b[0] + 1;
  const maxWidth = Math.max(rWidth, gWidth, bWidth);
  let total = 0;
  const partialSum = [];
  switch (maxWidth) {
    case rWidth: {
      for (let i = vbox.r[0]; i <= vbox.r[1]; i++) {
        let sum = 0;
        for (let j = vbox.g[0]; j <= vbox.g[1]; j++) {
          for (let k = vbox.b[0]; k <= vbox.b[1]; k++) {
            const index = getColorIndex(i, j, k);
            sum += histogram[index] || 0;
          }
        }
        total += sum;
        partialSum[i] = total;
      }
      break;
    }
    case gWidth: {
      for (let i = vbox.g[0]; i <= vbox.g[1]; i++) {
        let sum = 0;
        for (let j = vbox.r[0]; j <= vbox.r[1]; j++) {
          for (let k = vbox.b[0]; k <= vbox.b[1]; k++) {
            const index = getColorIndex(j, i, k);
            sum += histogram[index] || 0;
          }
        }
        total += sum;
        partialSum[i] = total;
      }
      break;
    }
    case bWidth: {
      for (let i = vbox.b[0]; i <= vbox.b[1]; i++) {
        let sum = 0;
        for (let j = vbox.r[0]; j <= vbox.r[1]; j++) {
          for (let k = vbox.g[0]; k <= vbox.g[1]; k++) {
            const index = getColorIndex(j, k, i);
            sum += histogram[index] || 0;
          }
        }
        total += sum;
        partialSum[i] = total;
      }
      break;
    }
  }
  const lookAheadSum = partialSum.map((d) => total - d);
  const cut = (color) => {
    for (let i = vbox[color][0]; i <= vbox[color][1]; i++) {
      if (partialSum[i] > total / 2) {
        const vbox1 = vbox.copy();
        const vbox2 = vbox.copy();
        const left = i - vbox[color][0];
        const right = vbox[color][1] - i;
        let d = left <= right ? Math.min(vbox[color][1] - 1, Math.trunc(i + right / 2)) : Math.max(vbox[color][0], Math.trunc(i - 1 - left / 2));
        while (!partialSum[d]) {
          d++;
        }
        let count = lookAheadSum[d];
        while (!count && partialSum[d - 1]) {
          count = lookAheadSum[--d];
        }
        vbox1[color][1] = d;
        vbox2[color][0] = vbox1[color][1] + 1;
        return [vbox1, vbox2];
      }
    }
    throw new Error("VBox can't be cut");
  };
  switch (maxWidth) {
    case rWidth:
      return cut("r");
    case gWidth:
      return cut("g");
    case bWidth:
      return cut("b");
    default:
      throw new Error("Case Not Possible");
  }
};
var quantize = (pixels, maxColors) => {
  if (pixels.length === 0 || maxColors < 2 || maxColors > 256) {
    throw new Error("Either no pixels provided or maxColors is not in range 2 -> 256");
  }
  const histogram = getHistogram(pixels);
  const vbox = vBoxFromPixels(pixels, histogram);
  const pq = new PriorityQueue((a, b) => a.count() - b.count());
  pq.push(vbox);
  const iter = (pq3, target) => {
    let nColors = pq3.length;
    let nIters = 0;
    while (nIters < maxIterations) {
      if (nColors >= target)
        return;
      if (nIters++ > maxIterations)
        return;
      const vbox2 = pq3.pop();
      if (!vbox2.count()) {
        pq3.push(vbox2);
        nIters++;
        continue;
      }
      const [vbox1, vbox22] = medianCutApply(histogram, vbox2);
      pq3.push(vbox1);
      if (vbox22) {
        pq3.push(vbox22);
        nColors++;
      }
    }
  };
  iter(pq, fractionByPopulations * maxColors);
  const pq2 = new PriorityQueue((a, b) => a.count() * a.volume() - b.count() * b.volume());
  while (pq.length) {
    pq2.push(pq.pop());
  }
  iter(pq2, maxColors);
  const cMap = new CMap();
  while (pq2.length) {
    cMap.push(pq2.pop());
  }
  return cMap;
};
var quantize_default = quantize;

// src/main.ts
function createPixelArray(pixels, pixelCount, quality) {
  const pixelArray = [];
  for (let i = 0; i < pixelCount; i = i + quality) {
    const offset = i * 4;
    const r = pixels[offset + 0];
    const g = pixels[offset + 1];
    const b = pixels[offset + 2];
    const a = pixels[offset + 3];
    if (typeof a === "undefined" || a >= 125) {
      if (!(r > 250 && g > 250 && b > 250)) {
        pixelArray.push([r, g, b]);
      }
    }
  }
  return pixelArray;
}
var getPalette = async (url, colorCount = 10, quality = 10) => {
  const imgData = await getPixelsFromURL(url);
  const pixelCount = imgData.shape[0] * imgData.shape[1];
  const pixelArray = createPixelArray(imgData.data, pixelCount, quality);
  return quantize_default(pixelArray, colorCount).palette();
};
var getColor = async (url, quality = 10) => (await getPalette(url, 5, quality))[0];

exports.getColor = getColor;
exports.getPalette = getPalette;
